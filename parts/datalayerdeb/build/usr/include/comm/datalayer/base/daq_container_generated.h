// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DAQCONTAINER_COMM_DATALAYER_DAQ_H_
#define FLATBUFFERS_GENERATED_DAQCONTAINER_COMM_DATALAYER_DAQ_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 4,
             "Non-compatible flatbuffers version included");

#include "array-of-bool8_generated.h"
#include "array-of-double_generated.h"
#include "array-of-float32_generated.h"
#include "array-of-float64_generated.h"
#include "array-of-int16_generated.h"
#include "array-of-int32_generated.h"
#include "array-of-int64_generated.h"
#include "array-of-int8_generated.h"
#include "array-of-string_generated.h"
#include "array-of-timestamp_generated.h"
#include "array-of-uint16_generated.h"
#include "array-of-uint32_generated.h"
#include "array-of-uint64_generated.h"
#include "array-of-uint8_generated.h"

namespace comm {
namespace datalayer {
namespace daq {

struct Tag;
struct TagBuilder;
struct TagT;

struct Equidistant;
struct EquidistantBuilder;
struct EquidistantT;

struct NonEquidistant;
struct NonEquidistantBuilder;
struct NonEquidistantT;

struct DaqContainer;
struct DaqContainerBuilder;
struct DaqContainerT;

/// union of all array types
enum Array : uint8_t {
  Array_NONE = 0,
  Array_ArrayOfBool8 = 1,
  Array_ArrayOfFloat32 = 2,
  Array_ArrayOfFloat64 = 3,
  Array_ArrayOfDouble = 4,
  Array_ArrayOfInt8 = 5,
  Array_ArrayOfInt16 = 6,
  Array_ArrayOfInt32 = 7,
  Array_ArrayOfInt64 = 8,
  Array_ArrayOfUInt8 = 9,
  Array_ArrayOfUInt16 = 10,
  Array_ArrayOfUInt32 = 11,
  Array_ArrayOfUInt64 = 12,
  Array_ArrayOfTimestamp = 13,
  Array_ArrayOfString = 14,
  Array_MIN = Array_NONE,
  Array_MAX = Array_ArrayOfString
};

inline const Array (&EnumValuesArray())[15] {
  static const Array values[] = {
    Array_NONE,
    Array_ArrayOfBool8,
    Array_ArrayOfFloat32,
    Array_ArrayOfFloat64,
    Array_ArrayOfDouble,
    Array_ArrayOfInt8,
    Array_ArrayOfInt16,
    Array_ArrayOfInt32,
    Array_ArrayOfInt64,
    Array_ArrayOfUInt8,
    Array_ArrayOfUInt16,
    Array_ArrayOfUInt32,
    Array_ArrayOfUInt64,
    Array_ArrayOfTimestamp,
    Array_ArrayOfString
  };
  return values;
}

inline const char * const *EnumNamesArray() {
  static const char * const names[16] = {
    "NONE",
    "ArrayOfBool8",
    "ArrayOfFloat32",
    "ArrayOfFloat64",
    "ArrayOfDouble",
    "ArrayOfInt8",
    "ArrayOfInt16",
    "ArrayOfInt32",
    "ArrayOfInt64",
    "ArrayOfUInt8",
    "ArrayOfUInt16",
    "ArrayOfUInt32",
    "ArrayOfUInt64",
    "ArrayOfTimestamp",
    "ArrayOfString",
    nullptr
  };
  return names;
}

inline const char *EnumNameArray(Array e) {
  if (::flatbuffers::IsOutRange(e, Array_NONE, Array_ArrayOfString)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArray()[index];
}

template<typename T> struct ArrayTraits {
  static const Array enum_value = Array_NONE;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfBool8> {
  static const Array enum_value = Array_ArrayOfBool8;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfFloat32> {
  static const Array enum_value = Array_ArrayOfFloat32;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfFloat64> {
  static const Array enum_value = Array_ArrayOfFloat64;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfDouble> {
  static const Array enum_value = Array_ArrayOfDouble;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfInt8> {
  static const Array enum_value = Array_ArrayOfInt8;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfInt16> {
  static const Array enum_value = Array_ArrayOfInt16;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfInt32> {
  static const Array enum_value = Array_ArrayOfInt32;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfInt64> {
  static const Array enum_value = Array_ArrayOfInt64;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfUInt8> {
  static const Array enum_value = Array_ArrayOfUInt8;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfUInt16> {
  static const Array enum_value = Array_ArrayOfUInt16;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfUInt32> {
  static const Array enum_value = Array_ArrayOfUInt32;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfUInt64> {
  static const Array enum_value = Array_ArrayOfUInt64;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfTimestamp> {
  static const Array enum_value = Array_ArrayOfTimestamp;
};

template<> struct ArrayTraits<comm::datalayer::ArrayOfString> {
  static const Array enum_value = Array_ArrayOfString;
};

template<typename T> struct ArrayUnionTraits {
  static const Array enum_value = Array_NONE;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfBool8T> {
  static const Array enum_value = Array_ArrayOfBool8;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfFloat32T> {
  static const Array enum_value = Array_ArrayOfFloat32;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfFloat64T> {
  static const Array enum_value = Array_ArrayOfFloat64;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfDoubleT> {
  static const Array enum_value = Array_ArrayOfDouble;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfInt8T> {
  static const Array enum_value = Array_ArrayOfInt8;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfInt16T> {
  static const Array enum_value = Array_ArrayOfInt16;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfInt32T> {
  static const Array enum_value = Array_ArrayOfInt32;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfInt64T> {
  static const Array enum_value = Array_ArrayOfInt64;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfUInt8T> {
  static const Array enum_value = Array_ArrayOfUInt8;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfUInt16T> {
  static const Array enum_value = Array_ArrayOfUInt16;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfUInt32T> {
  static const Array enum_value = Array_ArrayOfUInt32;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfUInt64T> {
  static const Array enum_value = Array_ArrayOfUInt64;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfTimestampT> {
  static const Array enum_value = Array_ArrayOfTimestamp;
};

template<> struct ArrayUnionTraits<comm::datalayer::ArrayOfStringT> {
  static const Array enum_value = Array_ArrayOfString;
};

struct ArrayUnion {
  Array type;
  void *value;

  ArrayUnion() : type(Array_NONE), value(nullptr) {}
  ArrayUnion(ArrayUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Array_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ArrayUnion(const ArrayUnion &);
  ArrayUnion &operator=(const ArrayUnion &u)
    { ArrayUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ArrayUnion &operator=(ArrayUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ArrayUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ArrayUnionTraits<RT>::enum_value;
    if (type != Array_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Array type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  comm::datalayer::ArrayOfBool8T *AsArrayOfBool8() {
    return type == Array_ArrayOfBool8 ?
      reinterpret_cast<comm::datalayer::ArrayOfBool8T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfBool8T *AsArrayOfBool8() const {
    return type == Array_ArrayOfBool8 ?
      reinterpret_cast<const comm::datalayer::ArrayOfBool8T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfFloat32T *AsArrayOfFloat32() {
    return type == Array_ArrayOfFloat32 ?
      reinterpret_cast<comm::datalayer::ArrayOfFloat32T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfFloat32T *AsArrayOfFloat32() const {
    return type == Array_ArrayOfFloat32 ?
      reinterpret_cast<const comm::datalayer::ArrayOfFloat32T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfFloat64T *AsArrayOfFloat64() {
    return type == Array_ArrayOfFloat64 ?
      reinterpret_cast<comm::datalayer::ArrayOfFloat64T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfFloat64T *AsArrayOfFloat64() const {
    return type == Array_ArrayOfFloat64 ?
      reinterpret_cast<const comm::datalayer::ArrayOfFloat64T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfDoubleT *AsArrayOfDouble() {
    return type == Array_ArrayOfDouble ?
      reinterpret_cast<comm::datalayer::ArrayOfDoubleT *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfDoubleT *AsArrayOfDouble() const {
    return type == Array_ArrayOfDouble ?
      reinterpret_cast<const comm::datalayer::ArrayOfDoubleT *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfInt8T *AsArrayOfInt8() {
    return type == Array_ArrayOfInt8 ?
      reinterpret_cast<comm::datalayer::ArrayOfInt8T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfInt8T *AsArrayOfInt8() const {
    return type == Array_ArrayOfInt8 ?
      reinterpret_cast<const comm::datalayer::ArrayOfInt8T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfInt16T *AsArrayOfInt16() {
    return type == Array_ArrayOfInt16 ?
      reinterpret_cast<comm::datalayer::ArrayOfInt16T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfInt16T *AsArrayOfInt16() const {
    return type == Array_ArrayOfInt16 ?
      reinterpret_cast<const comm::datalayer::ArrayOfInt16T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfInt32T *AsArrayOfInt32() {
    return type == Array_ArrayOfInt32 ?
      reinterpret_cast<comm::datalayer::ArrayOfInt32T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfInt32T *AsArrayOfInt32() const {
    return type == Array_ArrayOfInt32 ?
      reinterpret_cast<const comm::datalayer::ArrayOfInt32T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfInt64T *AsArrayOfInt64() {
    return type == Array_ArrayOfInt64 ?
      reinterpret_cast<comm::datalayer::ArrayOfInt64T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfInt64T *AsArrayOfInt64() const {
    return type == Array_ArrayOfInt64 ?
      reinterpret_cast<const comm::datalayer::ArrayOfInt64T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfUInt8T *AsArrayOfUInt8() {
    return type == Array_ArrayOfUInt8 ?
      reinterpret_cast<comm::datalayer::ArrayOfUInt8T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt8T *AsArrayOfUInt8() const {
    return type == Array_ArrayOfUInt8 ?
      reinterpret_cast<const comm::datalayer::ArrayOfUInt8T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfUInt16T *AsArrayOfUInt16() {
    return type == Array_ArrayOfUInt16 ?
      reinterpret_cast<comm::datalayer::ArrayOfUInt16T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt16T *AsArrayOfUInt16() const {
    return type == Array_ArrayOfUInt16 ?
      reinterpret_cast<const comm::datalayer::ArrayOfUInt16T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfUInt32T *AsArrayOfUInt32() {
    return type == Array_ArrayOfUInt32 ?
      reinterpret_cast<comm::datalayer::ArrayOfUInt32T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt32T *AsArrayOfUInt32() const {
    return type == Array_ArrayOfUInt32 ?
      reinterpret_cast<const comm::datalayer::ArrayOfUInt32T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfUInt64T *AsArrayOfUInt64() {
    return type == Array_ArrayOfUInt64 ?
      reinterpret_cast<comm::datalayer::ArrayOfUInt64T *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt64T *AsArrayOfUInt64() const {
    return type == Array_ArrayOfUInt64 ?
      reinterpret_cast<const comm::datalayer::ArrayOfUInt64T *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfTimestampT *AsArrayOfTimestamp() {
    return type == Array_ArrayOfTimestamp ?
      reinterpret_cast<comm::datalayer::ArrayOfTimestampT *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfTimestampT *AsArrayOfTimestamp() const {
    return type == Array_ArrayOfTimestamp ?
      reinterpret_cast<const comm::datalayer::ArrayOfTimestampT *>(value) : nullptr;
  }
  comm::datalayer::ArrayOfStringT *AsArrayOfString() {
    return type == Array_ArrayOfString ?
      reinterpret_cast<comm::datalayer::ArrayOfStringT *>(value) : nullptr;
  }
  const comm::datalayer::ArrayOfStringT *AsArrayOfString() const {
    return type == Array_ArrayOfString ?
      reinterpret_cast<const comm::datalayer::ArrayOfStringT *>(value) : nullptr;
  }
};

bool VerifyArray(::flatbuffers::Verifier &verifier, const void *obj, Array type);
bool VerifyArrayVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct TagT : public ::flatbuffers::NativeTable {
  typedef Tag TableType;
  std::string key{};
  std::string value{};
};

/// tag as key-value-pair for meta data
struct Tag FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TagT NativeTableType;
  typedef TagBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  /// unique key of the tag
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const Tag * const o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *_key) const {
    return strcmp(key()->c_str(), _key);
  }
  /// value of the tag
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  TagT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Tag> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TagT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagBuilder {
  typedef Tag Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(Tag::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(Tag::VT_VALUE, value);
  }
  explicit TagBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tag>(end);
    fbb_.Required(o, Tag::VT_KEY);
    return o;
  }
};

inline ::flatbuffers::Offset<Tag> CreateTag(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  TagBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tag> CreateTagDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return comm::datalayer::daq::CreateTag(
      _fbb,
      key__,
      value__);
}

::flatbuffers::Offset<Tag> CreateTag(::flatbuffers::FlatBufferBuilder &_fbb, const TagT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EquidistantT : public ::flatbuffers::NativeTable {
  typedef Equidistant TableType;
  std::string name{};
  std::vector<std::unique_ptr<comm::datalayer::daq::TagT>> tags{};
  uint64_t timestampNs = 0;
  uint64_t intervalNs = 0;
  comm::datalayer::daq::ArrayUnion array{};
  EquidistantT() = default;
  EquidistantT(const EquidistantT &o);
  EquidistantT(EquidistantT&&) FLATBUFFERS_NOEXCEPT = default;
  EquidistantT &operator=(EquidistantT o) FLATBUFFERS_NOEXCEPT;
};

/// equidistant DAQ data
struct Equidistant FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EquidistantT NativeTableType;
  typedef EquidistantBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TAGS = 6,
    VT_TIMESTAMPNS = 8,
    VT_INTERVALNS = 10,
    VT_ARRAY_TYPE = 12,
    VT_ARRAY = 14
  };
  /// unique name of the equidistant data
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Equidistant * const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  /// array of tags for meta data
  const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *>(VT_TAGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *mutable_tags() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *>(VT_TAGS);
  }
  /// unix epoch time (since 1.1.1970) for the 1st value in array in [ns]
  uint64_t timestampNs() const {
    return GetField<uint64_t>(VT_TIMESTAMPNS, 0);
  }
  bool mutate_timestampNs(uint64_t _timestampNs = 0) {
    return SetField<uint64_t>(VT_TIMESTAMPNS, _timestampNs, 0);
  }
  /// sampling interval in [ns]
  uint64_t intervalNs() const {
    return GetField<uint64_t>(VT_INTERVALNS, 0);
  }
  bool mutate_intervalNs(uint64_t _intervalNs = 0) {
    return SetField<uint64_t>(VT_INTERVALNS, _intervalNs, 0);
  }
  comm::datalayer::daq::Array array_type() const {
    return static_cast<comm::datalayer::daq::Array>(GetField<uint8_t>(VT_ARRAY_TYPE, 0));
  }
  /// array of equidistant sampled values starting at timestamp [ns] with interval [ns]
  const void *array() const {
    return GetPointer<const void *>(VT_ARRAY);
  }
  template<typename T> const T *array_as() const;
  const comm::datalayer::ArrayOfBool8 *array_as_ArrayOfBool8() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfBool8 ? static_cast<const comm::datalayer::ArrayOfBool8 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfFloat32 *array_as_ArrayOfFloat32() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfFloat32 ? static_cast<const comm::datalayer::ArrayOfFloat32 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfFloat64 *array_as_ArrayOfFloat64() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfFloat64 ? static_cast<const comm::datalayer::ArrayOfFloat64 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfDouble *array_as_ArrayOfDouble() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfDouble ? static_cast<const comm::datalayer::ArrayOfDouble *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt8 *array_as_ArrayOfInt8() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt8 ? static_cast<const comm::datalayer::ArrayOfInt8 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt16 *array_as_ArrayOfInt16() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt16 ? static_cast<const comm::datalayer::ArrayOfInt16 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt32 *array_as_ArrayOfInt32() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt32 ? static_cast<const comm::datalayer::ArrayOfInt32 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt64 *array_as_ArrayOfInt64() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt64 ? static_cast<const comm::datalayer::ArrayOfInt64 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt8 *array_as_ArrayOfUInt8() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt8 ? static_cast<const comm::datalayer::ArrayOfUInt8 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt16 *array_as_ArrayOfUInt16() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt16 ? static_cast<const comm::datalayer::ArrayOfUInt16 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt32 *array_as_ArrayOfUInt32() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt32 ? static_cast<const comm::datalayer::ArrayOfUInt32 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt64 *array_as_ArrayOfUInt64() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt64 ? static_cast<const comm::datalayer::ArrayOfUInt64 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfTimestamp *array_as_ArrayOfTimestamp() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfTimestamp ? static_cast<const comm::datalayer::ArrayOfTimestamp *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfString *array_as_ArrayOfString() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfString ? static_cast<const comm::datalayer::ArrayOfString *>(array()) : nullptr;
  }
  void *mutable_array() {
    return GetPointer<void *>(VT_ARRAY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfTables(tags()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMPNS, 8) &&
           VerifyField<uint64_t>(verifier, VT_INTERVALNS, 8) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAY) &&
           VerifyArray(verifier, array(), array_type()) &&
           verifier.EndTable();
  }
  EquidistantT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EquidistantT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Equidistant> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EquidistantT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const comm::datalayer::ArrayOfBool8 *Equidistant::array_as<comm::datalayer::ArrayOfBool8>() const {
  return array_as_ArrayOfBool8();
}

template<> inline const comm::datalayer::ArrayOfFloat32 *Equidistant::array_as<comm::datalayer::ArrayOfFloat32>() const {
  return array_as_ArrayOfFloat32();
}

template<> inline const comm::datalayer::ArrayOfFloat64 *Equidistant::array_as<comm::datalayer::ArrayOfFloat64>() const {
  return array_as_ArrayOfFloat64();
}

template<> inline const comm::datalayer::ArrayOfDouble *Equidistant::array_as<comm::datalayer::ArrayOfDouble>() const {
  return array_as_ArrayOfDouble();
}

template<> inline const comm::datalayer::ArrayOfInt8 *Equidistant::array_as<comm::datalayer::ArrayOfInt8>() const {
  return array_as_ArrayOfInt8();
}

template<> inline const comm::datalayer::ArrayOfInt16 *Equidistant::array_as<comm::datalayer::ArrayOfInt16>() const {
  return array_as_ArrayOfInt16();
}

template<> inline const comm::datalayer::ArrayOfInt32 *Equidistant::array_as<comm::datalayer::ArrayOfInt32>() const {
  return array_as_ArrayOfInt32();
}

template<> inline const comm::datalayer::ArrayOfInt64 *Equidistant::array_as<comm::datalayer::ArrayOfInt64>() const {
  return array_as_ArrayOfInt64();
}

template<> inline const comm::datalayer::ArrayOfUInt8 *Equidistant::array_as<comm::datalayer::ArrayOfUInt8>() const {
  return array_as_ArrayOfUInt8();
}

template<> inline const comm::datalayer::ArrayOfUInt16 *Equidistant::array_as<comm::datalayer::ArrayOfUInt16>() const {
  return array_as_ArrayOfUInt16();
}

template<> inline const comm::datalayer::ArrayOfUInt32 *Equidistant::array_as<comm::datalayer::ArrayOfUInt32>() const {
  return array_as_ArrayOfUInt32();
}

template<> inline const comm::datalayer::ArrayOfUInt64 *Equidistant::array_as<comm::datalayer::ArrayOfUInt64>() const {
  return array_as_ArrayOfUInt64();
}

template<> inline const comm::datalayer::ArrayOfTimestamp *Equidistant::array_as<comm::datalayer::ArrayOfTimestamp>() const {
  return array_as_ArrayOfTimestamp();
}

template<> inline const comm::datalayer::ArrayOfString *Equidistant::array_as<comm::datalayer::ArrayOfString>() const {
  return array_as_ArrayOfString();
}

struct EquidistantBuilder {
  typedef Equidistant Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Equidistant::VT_NAME, name);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>>> tags) {
    fbb_.AddOffset(Equidistant::VT_TAGS, tags);
  }
  void add_timestampNs(uint64_t timestampNs) {
    fbb_.AddElement<uint64_t>(Equidistant::VT_TIMESTAMPNS, timestampNs, 0);
  }
  void add_intervalNs(uint64_t intervalNs) {
    fbb_.AddElement<uint64_t>(Equidistant::VT_INTERVALNS, intervalNs, 0);
  }
  void add_array_type(comm::datalayer::daq::Array array_type) {
    fbb_.AddElement<uint8_t>(Equidistant::VT_ARRAY_TYPE, static_cast<uint8_t>(array_type), 0);
  }
  void add_array(::flatbuffers::Offset<void> array) {
    fbb_.AddOffset(Equidistant::VT_ARRAY, array);
  }
  explicit EquidistantBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Equidistant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Equidistant>(end);
    fbb_.Required(o, Equidistant::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Equidistant> CreateEquidistant(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>>> tags = 0,
    uint64_t timestampNs = 0,
    uint64_t intervalNs = 0,
    comm::datalayer::daq::Array array_type = comm::datalayer::daq::Array_NONE,
    ::flatbuffers::Offset<void> array = 0) {
  EquidistantBuilder builder_(_fbb);
  builder_.add_intervalNs(intervalNs);
  builder_.add_timestampNs(timestampNs);
  builder_.add_array(array);
  builder_.add_tags(tags);
  builder_.add_name(name);
  builder_.add_array_type(array_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Equidistant> CreateEquidistantDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    std::vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *tags = nullptr,
    uint64_t timestampNs = 0,
    uint64_t intervalNs = 0,
    comm::datalayer::daq::Array array_type = comm::datalayer::daq::Array_NONE,
    ::flatbuffers::Offset<void> array = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tags__ = tags ? _fbb.CreateVectorOfSortedTables<comm::datalayer::daq::Tag>(tags) : 0;
  return comm::datalayer::daq::CreateEquidistant(
      _fbb,
      name__,
      tags__,
      timestampNs,
      intervalNs,
      array_type,
      array);
}

::flatbuffers::Offset<Equidistant> CreateEquidistant(::flatbuffers::FlatBufferBuilder &_fbb, const EquidistantT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NonEquidistantT : public ::flatbuffers::NativeTable {
  typedef NonEquidistant TableType;
  std::string name{};
  std::vector<std::unique_ptr<comm::datalayer::daq::TagT>> tags{};
  std::vector<uint64_t> timestampsNs{};
  comm::datalayer::daq::ArrayUnion array{};
  NonEquidistantT() = default;
  NonEquidistantT(const NonEquidistantT &o);
  NonEquidistantT(NonEquidistantT&&) FLATBUFFERS_NOEXCEPT = default;
  NonEquidistantT &operator=(NonEquidistantT o) FLATBUFFERS_NOEXCEPT;
};

///  non-equidistant DAQ data
struct NonEquidistant FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NonEquidistantT NativeTableType;
  typedef NonEquidistantBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TAGS = 6,
    VT_TIMESTAMPSNS = 8,
    VT_ARRAY_TYPE = 10,
    VT_ARRAY = 12
  };
  /// unique name of the non-equidistant data
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const NonEquidistant * const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  /// array of tags for meta data
  const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *>(VT_TAGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *mutable_tags() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *>(VT_TAGS);
  }
  /// array of unix epoch time (since 1.1.1970) in [ns]
  const ::flatbuffers::Vector<uint64_t> *timestampsNs() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_TIMESTAMPSNS);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_timestampsNs() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_TIMESTAMPSNS);
  }
  comm::datalayer::daq::Array array_type() const {
    return static_cast<comm::datalayer::daq::Array>(GetField<uint8_t>(VT_ARRAY_TYPE, 0));
  }
  /// array of sampled values at the corresponding timestamps
  const void *array() const {
    return GetPointer<const void *>(VT_ARRAY);
  }
  template<typename T> const T *array_as() const;
  const comm::datalayer::ArrayOfBool8 *array_as_ArrayOfBool8() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfBool8 ? static_cast<const comm::datalayer::ArrayOfBool8 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfFloat32 *array_as_ArrayOfFloat32() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfFloat32 ? static_cast<const comm::datalayer::ArrayOfFloat32 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfFloat64 *array_as_ArrayOfFloat64() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfFloat64 ? static_cast<const comm::datalayer::ArrayOfFloat64 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfDouble *array_as_ArrayOfDouble() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfDouble ? static_cast<const comm::datalayer::ArrayOfDouble *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt8 *array_as_ArrayOfInt8() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt8 ? static_cast<const comm::datalayer::ArrayOfInt8 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt16 *array_as_ArrayOfInt16() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt16 ? static_cast<const comm::datalayer::ArrayOfInt16 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt32 *array_as_ArrayOfInt32() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt32 ? static_cast<const comm::datalayer::ArrayOfInt32 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfInt64 *array_as_ArrayOfInt64() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfInt64 ? static_cast<const comm::datalayer::ArrayOfInt64 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt8 *array_as_ArrayOfUInt8() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt8 ? static_cast<const comm::datalayer::ArrayOfUInt8 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt16 *array_as_ArrayOfUInt16() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt16 ? static_cast<const comm::datalayer::ArrayOfUInt16 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt32 *array_as_ArrayOfUInt32() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt32 ? static_cast<const comm::datalayer::ArrayOfUInt32 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfUInt64 *array_as_ArrayOfUInt64() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfUInt64 ? static_cast<const comm::datalayer::ArrayOfUInt64 *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfTimestamp *array_as_ArrayOfTimestamp() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfTimestamp ? static_cast<const comm::datalayer::ArrayOfTimestamp *>(array()) : nullptr;
  }
  const comm::datalayer::ArrayOfString *array_as_ArrayOfString() const {
    return array_type() == comm::datalayer::daq::Array_ArrayOfString ? static_cast<const comm::datalayer::ArrayOfString *>(array()) : nullptr;
  }
  void *mutable_array() {
    return GetPointer<void *>(VT_ARRAY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfTables(tags()) &&
           VerifyOffset(verifier, VT_TIMESTAMPSNS) &&
           verifier.VerifyVector(timestampsNs()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAY) &&
           VerifyArray(verifier, array(), array_type()) &&
           verifier.EndTable();
  }
  NonEquidistantT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NonEquidistantT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<NonEquidistant> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonEquidistantT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const comm::datalayer::ArrayOfBool8 *NonEquidistant::array_as<comm::datalayer::ArrayOfBool8>() const {
  return array_as_ArrayOfBool8();
}

template<> inline const comm::datalayer::ArrayOfFloat32 *NonEquidistant::array_as<comm::datalayer::ArrayOfFloat32>() const {
  return array_as_ArrayOfFloat32();
}

template<> inline const comm::datalayer::ArrayOfFloat64 *NonEquidistant::array_as<comm::datalayer::ArrayOfFloat64>() const {
  return array_as_ArrayOfFloat64();
}

template<> inline const comm::datalayer::ArrayOfDouble *NonEquidistant::array_as<comm::datalayer::ArrayOfDouble>() const {
  return array_as_ArrayOfDouble();
}

template<> inline const comm::datalayer::ArrayOfInt8 *NonEquidistant::array_as<comm::datalayer::ArrayOfInt8>() const {
  return array_as_ArrayOfInt8();
}

template<> inline const comm::datalayer::ArrayOfInt16 *NonEquidistant::array_as<comm::datalayer::ArrayOfInt16>() const {
  return array_as_ArrayOfInt16();
}

template<> inline const comm::datalayer::ArrayOfInt32 *NonEquidistant::array_as<comm::datalayer::ArrayOfInt32>() const {
  return array_as_ArrayOfInt32();
}

template<> inline const comm::datalayer::ArrayOfInt64 *NonEquidistant::array_as<comm::datalayer::ArrayOfInt64>() const {
  return array_as_ArrayOfInt64();
}

template<> inline const comm::datalayer::ArrayOfUInt8 *NonEquidistant::array_as<comm::datalayer::ArrayOfUInt8>() const {
  return array_as_ArrayOfUInt8();
}

template<> inline const comm::datalayer::ArrayOfUInt16 *NonEquidistant::array_as<comm::datalayer::ArrayOfUInt16>() const {
  return array_as_ArrayOfUInt16();
}

template<> inline const comm::datalayer::ArrayOfUInt32 *NonEquidistant::array_as<comm::datalayer::ArrayOfUInt32>() const {
  return array_as_ArrayOfUInt32();
}

template<> inline const comm::datalayer::ArrayOfUInt64 *NonEquidistant::array_as<comm::datalayer::ArrayOfUInt64>() const {
  return array_as_ArrayOfUInt64();
}

template<> inline const comm::datalayer::ArrayOfTimestamp *NonEquidistant::array_as<comm::datalayer::ArrayOfTimestamp>() const {
  return array_as_ArrayOfTimestamp();
}

template<> inline const comm::datalayer::ArrayOfString *NonEquidistant::array_as<comm::datalayer::ArrayOfString>() const {
  return array_as_ArrayOfString();
}

struct NonEquidistantBuilder {
  typedef NonEquidistant Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NonEquidistant::VT_NAME, name);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>>> tags) {
    fbb_.AddOffset(NonEquidistant::VT_TAGS, tags);
  }
  void add_timestampsNs(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> timestampsNs) {
    fbb_.AddOffset(NonEquidistant::VT_TIMESTAMPSNS, timestampsNs);
  }
  void add_array_type(comm::datalayer::daq::Array array_type) {
    fbb_.AddElement<uint8_t>(NonEquidistant::VT_ARRAY_TYPE, static_cast<uint8_t>(array_type), 0);
  }
  void add_array(::flatbuffers::Offset<void> array) {
    fbb_.AddOffset(NonEquidistant::VT_ARRAY, array);
  }
  explicit NonEquidistantBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NonEquidistant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NonEquidistant>(end);
    fbb_.Required(o, NonEquidistant::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<NonEquidistant> CreateNonEquidistant(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> timestampsNs = 0,
    comm::datalayer::daq::Array array_type = comm::datalayer::daq::Array_NONE,
    ::flatbuffers::Offset<void> array = 0) {
  NonEquidistantBuilder builder_(_fbb);
  builder_.add_array(array);
  builder_.add_timestampsNs(timestampsNs);
  builder_.add_tags(tags);
  builder_.add_name(name);
  builder_.add_array_type(array_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NonEquidistant> CreateNonEquidistantDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    std::vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *tags = nullptr,
    const std::vector<uint64_t> *timestampsNs = nullptr,
    comm::datalayer::daq::Array array_type = comm::datalayer::daq::Array_NONE,
    ::flatbuffers::Offset<void> array = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tags__ = tags ? _fbb.CreateVectorOfSortedTables<comm::datalayer::daq::Tag>(tags) : 0;
  auto timestampsNs__ = timestampsNs ? _fbb.CreateVector<uint64_t>(*timestampsNs) : 0;
  return comm::datalayer::daq::CreateNonEquidistant(
      _fbb,
      name__,
      tags__,
      timestampsNs__,
      array_type,
      array);
}

::flatbuffers::Offset<NonEquidistant> CreateNonEquidistant(::flatbuffers::FlatBufferBuilder &_fbb, const NonEquidistantT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DaqContainerT : public ::flatbuffers::NativeTable {
  typedef DaqContainer TableType;
  std::string name{};
  std::vector<std::unique_ptr<comm::datalayer::daq::TagT>> tags{};
  std::vector<std::unique_ptr<comm::datalayer::daq::EquidistantT>> equidistant{};
  std::vector<std::unique_ptr<comm::datalayer::daq::NonEquidistantT>> nonEquidistant{};
  DaqContainerT() = default;
  DaqContainerT(const DaqContainerT &o);
  DaqContainerT(DaqContainerT&&) FLATBUFFERS_NOEXCEPT = default;
  DaqContainerT &operator=(DaqContainerT o) FLATBUFFERS_NOEXCEPT;
};

/// DAQ container containing equidistant and non-equidistant daq data
struct DaqContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DaqContainerT NativeTableType;
  typedef DaqContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TAGS = 6,
    VT_EQUIDISTANT = 8,
    VT_NONEQUIDISTANT = 10
  };
  /// name of the DAQ container
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  /// array of tags for meta data
  const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *>(VT_TAGS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *mutable_tags() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *>(VT_TAGS);
  }
  /// array of equidistant data
  const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>> *equidistant() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>> *>(VT_EQUIDISTANT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>> *mutable_equidistant() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>> *>(VT_EQUIDISTANT);
  }
  /// array of non-equidistant data
  const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>> *nonEquidistant() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>> *>(VT_NONEQUIDISTANT);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>> *mutable_nonEquidistant() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>> *>(VT_NONEQUIDISTANT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfTables(tags()) &&
           VerifyOffset(verifier, VT_EQUIDISTANT) &&
           verifier.VerifyVector(equidistant()) &&
           verifier.VerifyVectorOfTables(equidistant()) &&
           VerifyOffset(verifier, VT_NONEQUIDISTANT) &&
           verifier.VerifyVector(nonEquidistant()) &&
           verifier.VerifyVectorOfTables(nonEquidistant()) &&
           verifier.EndTable();
  }
  DaqContainerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DaqContainerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DaqContainer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DaqContainerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DaqContainerBuilder {
  typedef DaqContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DaqContainer::VT_NAME, name);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>>> tags) {
    fbb_.AddOffset(DaqContainer::VT_TAGS, tags);
  }
  void add_equidistant(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>>> equidistant) {
    fbb_.AddOffset(DaqContainer::VT_EQUIDISTANT, equidistant);
  }
  void add_nonEquidistant(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>>> nonEquidistant) {
    fbb_.AddOffset(DaqContainer::VT_NONEQUIDISTANT, nonEquidistant);
  }
  explicit DaqContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DaqContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DaqContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DaqContainer> CreateDaqContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>>> equidistant = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>>> nonEquidistant = 0) {
  DaqContainerBuilder builder_(_fbb);
  builder_.add_nonEquidistant(nonEquidistant);
  builder_.add_equidistant(equidistant);
  builder_.add_tags(tags);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DaqContainer> CreateDaqContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    std::vector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> *tags = nullptr,
    std::vector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>> *equidistant = nullptr,
    std::vector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>> *nonEquidistant = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tags__ = tags ? _fbb.CreateVectorOfSortedTables<comm::datalayer::daq::Tag>(tags) : 0;
  auto equidistant__ = equidistant ? _fbb.CreateVectorOfSortedTables<comm::datalayer::daq::Equidistant>(equidistant) : 0;
  auto nonEquidistant__ = nonEquidistant ? _fbb.CreateVectorOfSortedTables<comm::datalayer::daq::NonEquidistant>(nonEquidistant) : 0;
  return comm::datalayer::daq::CreateDaqContainer(
      _fbb,
      name__,
      tags__,
      equidistant__,
      nonEquidistant__);
}

::flatbuffers::Offset<DaqContainer> CreateDaqContainer(::flatbuffers::FlatBufferBuilder &_fbb, const DaqContainerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TagT *Tag::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TagT>(new TagT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tag::UnPackTo(TagT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<Tag> Tag::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TagT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTag(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Tag> CreateTag(::flatbuffers::FlatBufferBuilder &_fbb, const TagT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TagT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateString(_o->key);
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return comm::datalayer::daq::CreateTag(
      _fbb,
      _key,
      _value);
}

inline EquidistantT::EquidistantT(const EquidistantT &o)
      : name(o.name),
        timestampNs(o.timestampNs),
        intervalNs(o.intervalNs),
        array(o.array) {
  tags.reserve(o.tags.size());
  for (const auto &tags_ : o.tags) { tags.emplace_back((tags_) ? new comm::datalayer::daq::TagT(*tags_) : nullptr); }
}

inline EquidistantT &EquidistantT::operator=(EquidistantT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(tags, o.tags);
  std::swap(timestampNs, o.timestampNs);
  std::swap(intervalNs, o.intervalNs);
  std::swap(array, o.array);
  return *this;
}

inline EquidistantT *Equidistant::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EquidistantT>(new EquidistantT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Equidistant::UnPackTo(EquidistantT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tags[_i]) { _e->Get(_i)->UnPackTo(_o->tags[_i].get(), _resolver); } else { _o->tags[_i] = std::unique_ptr<comm::datalayer::daq::TagT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tags.resize(0); } }
  { auto _e = timestampNs(); _o->timestampNs = _e; }
  { auto _e = intervalNs(); _o->intervalNs = _e; }
  { auto _e = array_type(); _o->array.type = _e; }
  { auto _e = array(); if (_e) _o->array.value = comm::datalayer::daq::ArrayUnion::UnPack(_e, array_type(), _resolver); }
}

inline ::flatbuffers::Offset<Equidistant> Equidistant::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EquidistantT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEquidistant(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Equidistant> CreateEquidistant(::flatbuffers::FlatBufferBuilder &_fbb, const EquidistantT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EquidistantT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _tags = _o->tags.size() ? _fbb.CreateVector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> (_o->tags.size(), [](size_t i, _VectorArgs *__va) { return CreateTag(*__va->__fbb, __va->__o->tags[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _timestampNs = _o->timestampNs;
  auto _intervalNs = _o->intervalNs;
  auto _array_type = _o->array.type;
  auto _array = _o->array.Pack(_fbb);
  return comm::datalayer::daq::CreateEquidistant(
      _fbb,
      _name,
      _tags,
      _timestampNs,
      _intervalNs,
      _array_type,
      _array);
}

inline NonEquidistantT::NonEquidistantT(const NonEquidistantT &o)
      : name(o.name),
        timestampsNs(o.timestampsNs),
        array(o.array) {
  tags.reserve(o.tags.size());
  for (const auto &tags_ : o.tags) { tags.emplace_back((tags_) ? new comm::datalayer::daq::TagT(*tags_) : nullptr); }
}

inline NonEquidistantT &NonEquidistantT::operator=(NonEquidistantT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(tags, o.tags);
  std::swap(timestampsNs, o.timestampsNs);
  std::swap(array, o.array);
  return *this;
}

inline NonEquidistantT *NonEquidistant::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NonEquidistantT>(new NonEquidistantT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NonEquidistant::UnPackTo(NonEquidistantT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tags[_i]) { _e->Get(_i)->UnPackTo(_o->tags[_i].get(), _resolver); } else { _o->tags[_i] = std::unique_ptr<comm::datalayer::daq::TagT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tags.resize(0); } }
  { auto _e = timestampsNs(); if (_e) { _o->timestampsNs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->timestampsNs[_i] = _e->Get(_i); } } else { _o->timestampsNs.resize(0); } }
  { auto _e = array_type(); _o->array.type = _e; }
  { auto _e = array(); if (_e) _o->array.value = comm::datalayer::daq::ArrayUnion::UnPack(_e, array_type(), _resolver); }
}

inline ::flatbuffers::Offset<NonEquidistant> NonEquidistant::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NonEquidistantT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNonEquidistant(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<NonEquidistant> CreateNonEquidistant(::flatbuffers::FlatBufferBuilder &_fbb, const NonEquidistantT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NonEquidistantT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _tags = _o->tags.size() ? _fbb.CreateVector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> (_o->tags.size(), [](size_t i, _VectorArgs *__va) { return CreateTag(*__va->__fbb, __va->__o->tags[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _timestampsNs = _o->timestampsNs.size() ? _fbb.CreateVector(_o->timestampsNs) : 0;
  auto _array_type = _o->array.type;
  auto _array = _o->array.Pack(_fbb);
  return comm::datalayer::daq::CreateNonEquidistant(
      _fbb,
      _name,
      _tags,
      _timestampsNs,
      _array_type,
      _array);
}

inline DaqContainerT::DaqContainerT(const DaqContainerT &o)
      : name(o.name) {
  tags.reserve(o.tags.size());
  for (const auto &tags_ : o.tags) { tags.emplace_back((tags_) ? new comm::datalayer::daq::TagT(*tags_) : nullptr); }
  equidistant.reserve(o.equidistant.size());
  for (const auto &equidistant_ : o.equidistant) { equidistant.emplace_back((equidistant_) ? new comm::datalayer::daq::EquidistantT(*equidistant_) : nullptr); }
  nonEquidistant.reserve(o.nonEquidistant.size());
  for (const auto &nonEquidistant_ : o.nonEquidistant) { nonEquidistant.emplace_back((nonEquidistant_) ? new comm::datalayer::daq::NonEquidistantT(*nonEquidistant_) : nullptr); }
}

inline DaqContainerT &DaqContainerT::operator=(DaqContainerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(tags, o.tags);
  std::swap(equidistant, o.equidistant);
  std::swap(nonEquidistant, o.nonEquidistant);
  return *this;
}

inline DaqContainerT *DaqContainer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DaqContainerT>(new DaqContainerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DaqContainer::UnPackTo(DaqContainerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tags[_i]) { _e->Get(_i)->UnPackTo(_o->tags[_i].get(), _resolver); } else { _o->tags[_i] = std::unique_ptr<comm::datalayer::daq::TagT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tags.resize(0); } }
  { auto _e = equidistant(); if (_e) { _o->equidistant.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->equidistant[_i]) { _e->Get(_i)->UnPackTo(_o->equidistant[_i].get(), _resolver); } else { _o->equidistant[_i] = std::unique_ptr<comm::datalayer::daq::EquidistantT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->equidistant.resize(0); } }
  { auto _e = nonEquidistant(); if (_e) { _o->nonEquidistant.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nonEquidistant[_i]) { _e->Get(_i)->UnPackTo(_o->nonEquidistant[_i].get(), _resolver); } else { _o->nonEquidistant[_i] = std::unique_ptr<comm::datalayer::daq::NonEquidistantT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->nonEquidistant.resize(0); } }
}

inline ::flatbuffers::Offset<DaqContainer> DaqContainer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DaqContainerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDaqContainer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DaqContainer> CreateDaqContainer(::flatbuffers::FlatBufferBuilder &_fbb, const DaqContainerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DaqContainerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _tags = _o->tags.size() ? _fbb.CreateVector<::flatbuffers::Offset<comm::datalayer::daq::Tag>> (_o->tags.size(), [](size_t i, _VectorArgs *__va) { return CreateTag(*__va->__fbb, __va->__o->tags[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _equidistant = _o->equidistant.size() ? _fbb.CreateVector<::flatbuffers::Offset<comm::datalayer::daq::Equidistant>> (_o->equidistant.size(), [](size_t i, _VectorArgs *__va) { return CreateEquidistant(*__va->__fbb, __va->__o->equidistant[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nonEquidistant = _o->nonEquidistant.size() ? _fbb.CreateVector<::flatbuffers::Offset<comm::datalayer::daq::NonEquidistant>> (_o->nonEquidistant.size(), [](size_t i, _VectorArgs *__va) { return CreateNonEquidistant(*__va->__fbb, __va->__o->nonEquidistant[i].get(), __va->__rehasher); }, &_va ) : 0;
  return comm::datalayer::daq::CreateDaqContainer(
      _fbb,
      _name,
      _tags,
      _equidistant,
      _nonEquidistant);
}

inline bool VerifyArray(::flatbuffers::Verifier &verifier, const void *obj, Array type) {
  switch (type) {
    case Array_NONE: {
      return true;
    }
    case Array_ArrayOfBool8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfBool8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfFloat32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfFloat32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfFloat64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfFloat64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfDouble: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfInt8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfInt16: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfInt32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfInt64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfUInt8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfUInt16: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfUInt32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfUInt64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfTimestamp: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfTimestamp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Array_ArrayOfString: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyArrayVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyArray(
        verifier,  values->Get(i), types->GetEnum<Array>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ArrayUnion::UnPack(const void *obj, Array type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Array_ArrayOfBool8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfBool8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfFloat32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfFloat32 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfFloat64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfFloat64 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfDouble: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfDouble *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfInt8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfInt16: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt16 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfInt32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt32 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfInt64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt64 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfUInt8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt8 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfUInt16: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt16 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfUInt32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt32 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfUInt64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt64 *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfTimestamp: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfTimestamp *>(obj);
      return ptr->UnPack(resolver);
    }
    case Array_ArrayOfString: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfString *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ArrayUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Array_ArrayOfBool8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfBool8T *>(value);
      return CreateArrayOfBool8(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfFloat32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfFloat32T *>(value);
      return CreateArrayOfFloat32(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfFloat64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfFloat64T *>(value);
      return CreateArrayOfFloat64(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfDouble: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfDoubleT *>(value);
      return CreateArrayOfDouble(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfInt8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt8T *>(value);
      return CreateArrayOfInt8(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfInt16: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt16T *>(value);
      return CreateArrayOfInt16(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfInt32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt32T *>(value);
      return CreateArrayOfInt32(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfInt64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfInt64T *>(value);
      return CreateArrayOfInt64(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfUInt8: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt8T *>(value);
      return CreateArrayOfUInt8(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfUInt16: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt16T *>(value);
      return CreateArrayOfUInt16(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfUInt32: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt32T *>(value);
      return CreateArrayOfUInt32(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfUInt64: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfUInt64T *>(value);
      return CreateArrayOfUInt64(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfTimestamp: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfTimestampT *>(value);
      return CreateArrayOfTimestamp(_fbb, ptr, _rehasher).Union();
    }
    case Array_ArrayOfString: {
      auto ptr = reinterpret_cast<const comm::datalayer::ArrayOfStringT *>(value);
      return CreateArrayOfString(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ArrayUnion::ArrayUnion(const ArrayUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Array_ArrayOfBool8: {
      value = new comm::datalayer::ArrayOfBool8T(*reinterpret_cast<comm::datalayer::ArrayOfBool8T *>(u.value));
      break;
    }
    case Array_ArrayOfFloat32: {
      value = new comm::datalayer::ArrayOfFloat32T(*reinterpret_cast<comm::datalayer::ArrayOfFloat32T *>(u.value));
      break;
    }
    case Array_ArrayOfFloat64: {
      value = new comm::datalayer::ArrayOfFloat64T(*reinterpret_cast<comm::datalayer::ArrayOfFloat64T *>(u.value));
      break;
    }
    case Array_ArrayOfDouble: {
      value = new comm::datalayer::ArrayOfDoubleT(*reinterpret_cast<comm::datalayer::ArrayOfDoubleT *>(u.value));
      break;
    }
    case Array_ArrayOfInt8: {
      value = new comm::datalayer::ArrayOfInt8T(*reinterpret_cast<comm::datalayer::ArrayOfInt8T *>(u.value));
      break;
    }
    case Array_ArrayOfInt16: {
      value = new comm::datalayer::ArrayOfInt16T(*reinterpret_cast<comm::datalayer::ArrayOfInt16T *>(u.value));
      break;
    }
    case Array_ArrayOfInt32: {
      value = new comm::datalayer::ArrayOfInt32T(*reinterpret_cast<comm::datalayer::ArrayOfInt32T *>(u.value));
      break;
    }
    case Array_ArrayOfInt64: {
      value = new comm::datalayer::ArrayOfInt64T(*reinterpret_cast<comm::datalayer::ArrayOfInt64T *>(u.value));
      break;
    }
    case Array_ArrayOfUInt8: {
      value = new comm::datalayer::ArrayOfUInt8T(*reinterpret_cast<comm::datalayer::ArrayOfUInt8T *>(u.value));
      break;
    }
    case Array_ArrayOfUInt16: {
      value = new comm::datalayer::ArrayOfUInt16T(*reinterpret_cast<comm::datalayer::ArrayOfUInt16T *>(u.value));
      break;
    }
    case Array_ArrayOfUInt32: {
      value = new comm::datalayer::ArrayOfUInt32T(*reinterpret_cast<comm::datalayer::ArrayOfUInt32T *>(u.value));
      break;
    }
    case Array_ArrayOfUInt64: {
      value = new comm::datalayer::ArrayOfUInt64T(*reinterpret_cast<comm::datalayer::ArrayOfUInt64T *>(u.value));
      break;
    }
    case Array_ArrayOfTimestamp: {
      value = new comm::datalayer::ArrayOfTimestampT(*reinterpret_cast<comm::datalayer::ArrayOfTimestampT *>(u.value));
      break;
    }
    case Array_ArrayOfString: {
      value = new comm::datalayer::ArrayOfStringT(*reinterpret_cast<comm::datalayer::ArrayOfStringT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ArrayUnion::Reset() {
  switch (type) {
    case Array_ArrayOfBool8: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfBool8T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfFloat32: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfFloat32T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfFloat64: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfFloat64T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfDouble: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfDoubleT *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfInt8: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfInt8T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfInt16: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfInt16T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfInt32: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfInt32T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfInt64: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfInt64T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfUInt8: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfUInt8T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfUInt16: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfUInt16T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfUInt32: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfUInt32T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfUInt64: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfUInt64T *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfTimestamp: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfTimestampT *>(value);
      delete ptr;
      break;
    }
    case Array_ArrayOfString: {
      auto ptr = reinterpret_cast<comm::datalayer::ArrayOfStringT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Array_NONE;
}

inline const comm::datalayer::daq::DaqContainer *GetDaqContainer(const void *buf) {
  return ::flatbuffers::GetRoot<comm::datalayer::daq::DaqContainer>(buf);
}

inline const comm::datalayer::daq::DaqContainer *GetSizePrefixedDaqContainer(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<comm::datalayer::daq::DaqContainer>(buf);
}

inline DaqContainer *GetMutableDaqContainer(void *buf) {
  return ::flatbuffers::GetMutableRoot<DaqContainer>(buf);
}

inline comm::datalayer::daq::DaqContainer *GetMutableSizePrefixedDaqContainer(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<comm::datalayer::daq::DaqContainer>(buf);
}

inline bool VerifyDaqContainerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<comm::datalayer::daq::DaqContainer>(nullptr);
}

inline bool VerifySizePrefixedDaqContainerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<comm::datalayer::daq::DaqContainer>(nullptr);
}

inline void FinishDaqContainerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<comm::datalayer::daq::DaqContainer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDaqContainerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<comm::datalayer::daq::DaqContainer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<comm::datalayer::daq::DaqContainerT> UnPackDaqContainer(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::daq::DaqContainerT>(GetDaqContainer(buf)->UnPack(res));
}

inline std::unique_ptr<comm::datalayer::daq::DaqContainerT> UnPackSizePrefixedDaqContainer(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::daq::DaqContainerT>(GetSizePrefixedDaqContainer(buf)->UnPack(res));
}

}  // namespace daq
}  // namespace datalayer
}  // namespace comm

#endif  // FLATBUFFERS_GENERATED_DAQCONTAINER_COMM_DATALAYER_DAQ_H_
